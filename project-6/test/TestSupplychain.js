// prepare the test env
var chai = require('../node_modules/chai');
chai.use(require('../node_modules/chai-as-promised'))
chai.should();

var expect = chai.expect;
var assert = chai.assert;

// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require('SupplyChain')

async function prepareAcconts(supplyChain, accounts) {
    // We will have 10 Available Accounts
    ///==================

    // Prepare the role account
    var eventsRoleAdded = new Array(false, false, false, false)

    await supplyChain.FarmerAdded().watch((err, res) => { eventsRoleAdded[0] = true })
    await supplyChain.DistributorAdded().watch((err, res) => { eventsRoleAdded[1] = true })
    await supplyChain.RetailerAdded().watch((err, res) => { eventsRoleAdded[2] = true })
    await supplyChain.ConsumerAdded().watch((err, res) => { eventsRoleAdded[3] = true })

    await supplyChain.addFarmer(accounts[1], { from:accounts[0] })
    await supplyChain.addDistributor(accounts[2], { from:accounts[0] })
    await supplyChain.addRetailer(accounts[3], { from:accounts[0] })
    await supplyChain.addConsumer(accounts[4], { from:accounts[0] })

    return eventsRoleAdded
}

async function assertItemResult(supplyChain, upc, expected) {

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

    // Verify the result set
    assert.equal(resultBufferOne[0], expected.sku, 'Error: Invalid item SKU')
    assert.equal(resultBufferOne[1], expected.upc, 'Error: Invalid item UPC')
    assert.equal(resultBufferOne[2], expected.ownerID, 'Error: Missing or Invalid ownerID')
    assert.equal(resultBufferOne[3], expected.originFarmerID, 'Error: Missing or Invalid originFarmerID')
    assert.equal(resultBufferOne[4], expected.originFarmName, 'Error: Missing or Invalid originFarmName')
    assert.equal(resultBufferOne[5], expected.originFarmInformation, 'Error: Missing or Invalid originFarmInformation')
    assert.equal(resultBufferOne[6], expected.originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude')
    assert.equal(resultBufferOne[7], expected.originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude')

    assert.equal(resultBufferTwo[0], expected.sku, 'Error: Invalid item SKU')
    assert.equal(resultBufferTwo[1], expected.upc, 'Error: Invalid item UPC')
    assert.equal(resultBufferTwo[2], expected.productID, 'Error: Missing or Invalid productID')
    assert.equal(resultBufferTwo[3], expected.productNotes, 'Error: Missing or Invalid productNotes')
    assert.equal(resultBufferTwo[4], expected.productPrice, 'Error: Missing or Invalid productPrice')
    assert.equal(resultBufferTwo[5], expected.itemState, 'Error: Invalid item itemState')
    assert.equal(resultBufferTwo[6], expected.distributorID, 'Error: Missing or Invalid distributorID')
    assert.equal(resultBufferTwo[7], expected.retailerID, 'Error: Missing or Invalid retailerID')
    assert.equal(resultBufferTwo[7], expected.consumerID, 'Error: Missing or Invalid consumerID')
}

contract('SupplyChain', function(accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    var sku_item1 = 1
    var upc_item1 = 1
    var sku_item2 = 2
    var upc_item2 = 2
    
    const ownerID = accounts[0]
    const originFarmerID = accounts[1]
    const originFarmName = "John Doe"
    const originFarmInformation = "Yarray Valley"
    const originFarmLatitude = "-38.239770"
    const originFarmLongitude = "144.341490"
    var productID = upc_item1
    const productNotes = "Best beans for Espresso"
    const productPrice = web3.toWei(1, "ether")

    const originFarmerID2 = accounts[5]
    const originFarmName2 = "John Doe 2"
    const originFarmInformation2 = "Yarray Valley 2"
    const originFarmLatitude2 = "-66.239770"
    const originFarmLongitude2 = "24.341490"    
    var productID2 = upc_item2
    const productNotes2 = "Best beans for Espresso 2"
    const productPrice2 = web3.toWei(2, "ether")

    var itemState = 0
    const distributorID = accounts[2]
    const retailerID = accounts[3]
    const consumerID = accounts[4]
    const emptyAddress = '0x00000000000000000000000000000000000000'

    // We will have 10 Available Accounts
    ///==================

    console.log("ganache-cli accounts used here...")
    console.log("Contract Owner: accounts[0] ", accounts[0])
    console.log("Farmer 1: accounts[1] ", accounts[1])
    console.log("Farmer 2: accounts[5] ", accounts[5])
    console.log("Distributor: accounts[2] ", accounts[2])
    console.log("Retailer: accounts[3] ", accounts[3])
    console.log("Consumer: accounts[4] ", accounts[4])

    // 1st Test
    // 
    // After the test case:
    //   item1 => harvested (newly created)
    //   item2 => harvested (newly created)
    it("Testing smart contract function harvestItem() that allows a farmer to harvest coffee", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Prepare the role account
        let eventsRoleAdded = await prepareAcconts(supplyChain, accounts)

        // Declare and Initialize a variable for event
        // Watch the emitted event Harvested()
        var eventEmitted = false
        await supplyChain.Harvested().watch((err, res) => { eventEmitted = true })
        
        // condition 1: good harvestItem
        {
            // Mark an item as Harvested by calling function harvestItem()
            await supplyChain.harvestItem(upc_item1,
                originFarmerID, originFarmName, originFarmInformation, originFarmLatitude, originFarmLongitude, productNotes)

            // Verify the result set
            await assertItemResult(supplyChain, upc_item1, {
                sku: sku_item1,
                upc: upc_item1,
                ownerID: originFarmerID,
                originFarmerID: originFarmerID,
                originFarmName: originFarmName,
                originFarmInformation: originFarmInformation,
                originFarmLatitude: originFarmLatitude,
                originFarmLongitude: originFarmLongitude,
                productID: productID,
                productNotes: productNotes,
                productPrice: 0,
                itemState: 0,
                distributorID: 0,
                retailerID: 0,
                consumerID: 0,
            })

            assert.equal(eventEmitted, true, 'Invalid event emitted')        
        }
        
        // now, let's validate roles-added events
        // we cannot do it immediately after the roles added, the delay is to give it some time to happen
        assert.equal(eventsRoleAdded[0] && eventsRoleAdded[1] && eventsRoleAdded[2] && eventsRoleAdded[3],
            true, 'Invalid events emitted: ' + eventsRoleAdded)        

        // condition 2: good harvestItem
        {
            eventEmitted = false

            // Mark an item as Harvested by calling function harvestItem()
            await supplyChain.harvestItem(0, originFarmerID2, originFarmName2, originFarmInformation2, originFarmLatitude2, originFarmLongitude2, productNotes2)

            // Verify the result set
            await assertItemResult(supplyChain, upc_item2, {
                sku: sku_item2,
                upc: upc_item2,
                ownerID: originFarmerID2,
                originFarmerID: originFarmerID2,
                originFarmName: originFarmName2,
                originFarmInformation: originFarmInformation2,
                originFarmLatitude: originFarmLatitude2,
                originFarmLongitude: originFarmLongitude2,
                productID: productID2,
                productNotes: productNotes2,
                productPrice: 0,
                itemState: 0,
                distributorID: 0,
                retailerID: 0,
                consumerID: 0,
            })

            assert.equal(eventEmitted, true, 'Invalid event emitted')        
        }

        // condition 3: bad harvestItem, wrong existing upc
        {
            assert.isRejected(supplyChain.harvestItem(
                upc_item1, originFarmerID2, originFarmName2, originFarmInformation2, originFarmLatitude2, originFarmLongitude2, productNotes2))
        }

        // condition 4: bad harvestItem, the caller is not a farmer
        {
            assert.isRejected(supplyChain.harvestItem(
                0, originFarmerID2, originFarmName2, originFarmInformation2, originFarmLatitude2, originFarmLongitude2, productNotes2,
                {from: accounts[4]}))
        }
    })    

    // 2nd Test
    // 
    // After the test case:
    //   item1 => processed (was harvested)
    //   item2 => harvested (was harvested)
    it("Testing smart contract function processItem() that allows a farmer to process coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        // Watch the emitted event Processed()
        var eventEmitted = false
        await supplyChain.Processed().watch((err, res) => { eventEmitted = true })

        // condition: good processtItem
        {
            // Mark an item as Processed by calling function processtItem()
            await supplyChain.processItem(upc_item1, { from: originFarmerID })

            // Verify the result set
            await assertItemResult(supplyChain, upc_item1, {
                sku: sku_item1,
                upc: upc_item1,
                ownerID: originFarmerID,
                originFarmerID: originFarmerID,
                originFarmName: originFarmName,
                originFarmInformation: originFarmInformation,
                originFarmLatitude: originFarmLatitude,
                originFarmLongitude: originFarmLongitude,
                productID: productID,
                productNotes: productNotes,
                productPrice: 0,
                itemState: 1,
                distributorID: 0,
                retailerID: 0,
                consumerID: 0,
            })

            assert.equal(eventEmitted, true, 'Invalid event emitted')        
        }

        // condition: bad processtItem, wrong item status
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.processItem(upc_item1, { from: originFarmerID }))
        }

        // condition: bad processtItem, wrong msg.sender (not from farmer)
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.processItem(upc_item2, { from: consumerID }))
        }

        // condition: bad processtItem, wrong msg.sender (from not-owner farmer)
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.processItem(upc_item2, { from: originFarmerID }))
        }

        // condition: bad processtItem, wrong upc
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.processItem(100000, { from: originFarmerID }))
        }
    })    

    // 3rd Test
    // 
    // After the test case:
    //   item1 => packed (was processed)
    //   item2 => processed (was harvested)
    it("Testing smart contract function packItem() that allows a farmer to pack coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        // Watch the emitted event Packed()
        var eventEmitted = false
        await supplyChain.Packed().watch((err, res) => { eventEmitted = true })
        
        // condition: good packItem
        {
            // Mark an item as Packed by calling function packItem()
            await supplyChain.packItem(upc_item1, { from: originFarmerID })

            // Verify the result set
            await assertItemResult(supplyChain, upc_item1, {
                sku: sku_item1,
                upc: upc_item1,
                ownerID: originFarmerID,
                originFarmerID: originFarmerID,
                originFarmName: originFarmName,
                originFarmInformation: originFarmInformation,
                originFarmLatitude: originFarmLatitude,
                originFarmLongitude: originFarmLongitude,
                productID: productID,
                productNotes: productNotes,
                productPrice: 0,
                itemState: 2,
                distributorID: 0,
                retailerID: 0,
                consumerID: 0,
            })

            assert.equal(eventEmitted, true, 'Invalid event emitted')        
        }
        
        // condition: bad packItem, wrong item status
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.packItem(upc_item1, { from: originFarmerID }))
            assert.isRejected(supplyChain.packItem(upc_item2, { from: originFarmerID2 }))
        }

        // condition: bad packItem, wrong upc
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.packItem(100000, { from: originFarmerID }))
        }

        // now: prepare item2 to the good status
        {
            // Mark an item as Processed by calling function processtItem()
            await supplyChain.processItem(upc_item2, { from: originFarmerID2 })

            // Verify the result set
            await assertItemResult(supplyChain, upc_item2, {
                sku: sku_item2,
                upc: upc_item2,
                ownerID: originFarmerID2,
                originFarmerID: originFarmerID2,
                originFarmName: originFarmName2,
                originFarmInformation: originFarmInformation2,
                originFarmLatitude: originFarmLatitude2,
                originFarmLongitude: originFarmLongitude2,
                productID: productID2,
                productNotes: productNotes2,
                productPrice: 0,
                itemState: 1,
                distributorID: 0,
                retailerID: 0,
                consumerID: 0,
            })
        }

        // condition: bad packItem, wrong msg.sender (not from farmer)
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.packItem(upc_item2, { from: consumerID }))
        }

        // condition: bad packItem, wrong msg.sender (from not-owner farmer)
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.packItem(upc_item2, { from: originFarmerID }))
        }
    })    

    // 4th Test
    // 
    // After the test case:
    //   item1 => forSale (was packed)
    //   item2 => packed (was processed)
    it("Testing smart contract function sellItem() that allows a farmer to sell coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        // Watch the emitted event ForSale()
        var eventEmitted = false
        await supplyChain.ForSale().watch((err, res) => { eventEmitted = true })
        
        // condition: good sellItem
        {
            // Mark an item as ForSale by calling function sellItem()
            await supplyChain.sellItem(upc_item1, productPrice, { from: originFarmerID })

            // Verify the result set
            await assertItemResult(supplyChain, upc_item1, {
                sku: sku_item1,
                upc: upc_item1,
                ownerID: originFarmerID,
                originFarmerID: originFarmerID,
                originFarmName: originFarmName,
                originFarmInformation: originFarmInformation,
                originFarmLatitude: originFarmLatitude,
                originFarmLongitude: originFarmLongitude,
                productID: productID,
                productNotes: productNotes,
                productPrice: productPrice,
                itemState: 3,
                distributorID: 0,
                retailerID: 0,
                consumerID: 0,
            })

            assert.equal(eventEmitted, true, 'Invalid event emitted')        
        }
        
        // condition: bad sellItem, wrong item status
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.sellItem(upc_item1, { from: originFarmerID }))
            assert.isRejected(supplyChain.sellItem(upc_item2, { from: originFarmerID2 }))
        }

        // condition: bad sellItem, wrong upc
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.packItem(100000, { from: originFarmerID }))
        }

        // now: prepare item2 to the good status
        {
            // Mark an item as Processed by calling function processtItem()
            await supplyChain.packItem(upc_item2, { from: originFarmerID2 })

            // Verify the result set
            await assertItemResult(supplyChain, upc_item2, {
                sku: sku_item2,
                upc: upc_item2,
                ownerID: originFarmerID2,
                originFarmerID: originFarmerID2,
                originFarmName: originFarmName2,
                originFarmInformation: originFarmInformation2,
                originFarmLatitude: originFarmLatitude2,
                originFarmLongitude: originFarmLongitude2,
                productID: productID2,
                productNotes: productNotes2,
                productPrice: 0,
                itemState: 2,
                distributorID: 0,
                retailerID: 0,
                consumerID: 0,
            })
        }

        // condition: bad sellItem, wrong msg.sender (not from farmer)
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.packItem(upc_item2, { from: consumerID }))
        }

        // condition: bad sellItem, wrong msg.sender (from not-owner farmer)
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.packItem(upc_item2, { from: originFarmerID }))
        }
    })    

    // 5th Test
    // 
    // After the test case:
    //   item1 => sold (was forSale)
    //   item2 => forSale (was packed)
    it("Testing smart contract function buyItem() that allows a distributor to buy coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        // Watch the emitted event Sold()
        var eventEmitted = false
        await supplyChain.Sold().watch((err, res) => { eventEmitted = true })
        
        // condition: good sellItem
        {
            let balanceFarmerBeforeTx = await web3.eth.getBalance(originFarmerID);
            let balanceDistributorBeforeTx = await web3.eth.getBalance(distributorID);

            // Mark an item as Sold by calling function buyItem()
            await supplyChain.buyItem(upc_item1, { from: distributorID, value: (productPrice*2) })

            // Verify the result set
            await assertItemResult(supplyChain, upc_item1, {
                sku: sku_item1,
                upc: upc_item1,
                ownerID: distributorID,
                originFarmerID: originFarmerID,
                originFarmName: originFarmName,
                originFarmInformation: originFarmInformation,
                originFarmLatitude: originFarmLatitude,
                originFarmLongitude: originFarmLongitude,
                productID: productID,
                productNotes: productNotes,
                productPrice: productPrice,
                itemState: 4,
                distributorID: distributorID,
                retailerID: 0,
                consumerID: 0,
            })

            assert.equal(eventEmitted, true, 'Invalid event emitted')        

            // check money wallet: farmer
            let balanceFarmerAfterTx = await web3.eth.getBalance(originFarmerID);
            let valueFarmer = Number(balanceFarmerAfterTx) - Number(balanceFarmerBeforeTx);
            assert.equal(valueFarmer, productPrice, 'wrong money transfer found -- farmer')
            // check money wallet: distributor
            let balanceDistributorAfterTx = await web3.eth.getBalance(distributorID);
            let valueDistributor = Number(balanceDistributorBeforeTx) - Number(balanceDistributorAfterTx);
            assert((valueDistributor > productPrice) && (valueDistributor < (productPrice*1.05)), 'wrong money transfer found -- distributor')
        }

        // condition: bad sellItem, wrong item status
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.buyItem(upc_item1, { from: distributorID, value: (productPrice) }))
            assert.isRejected(supplyChain.buyItem(upc_item2, { from: distributorID, value: (productPrice2) }))
        }

        // condition: bad sellItem, wrong upc
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.buyItem(100000, { from: distributorID, value: productPrice2 }))
        }

        // now: prepare item2 to the good status
        {
            // Mark an item as ForSale by calling function sellItem()
            await supplyChain.sellItem(upc_item2, productPrice2, { from: originFarmerID2 })

            // Verify the result set
            await assertItemResult(supplyChain, upc_item2, {
                sku: sku_item2,
                upc: upc_item2,
                ownerID: originFarmerID2,
                originFarmerID: originFarmerID2,
                originFarmName: originFarmName2,
                originFarmInformation: originFarmInformation2,
                originFarmLatitude: originFarmLatitude2,
                originFarmLongitude: originFarmLongitude2,
                productID: productID2,
                productNotes: productNotes2,
                productPrice: productPrice2,
                itemState: 3,
                distributorID: 0,
                retailerID: 0,
                consumerID: 0,
            })
        }

        // condition: bad sellItem, wrong msg.sender (not from distributor)
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.buyItem(upc_item2, { from: consumerID, value: productPrice2 }))
        }

        // condition: bad sellItem, not paid enough
        {
            // Mark an item as Processed by calling function processtItem()
            assert.isRejected(supplyChain.buyItem(upc_item2, { from: distributorID, value: (productPrice2/2) }))
        }
        
    })    

    // 6th Test
    it("Testing smart contract function shipItem() that allows a distributor to ship coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        
        
        // Watch the emitted event Shipped()
        

        // Mark an item as Sold by calling function buyItem()
        

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        

        // Verify the result set
              
    })    

    // 7th Test
    it("Testing smart contract function receiveItem() that allows a retailer to mark coffee received", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        
        
        // Watch the emitted event Received()
        

        // Mark an item as Sold by calling function buyItem()
        

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        

        // Verify the result set
             
    })    

    // 8th Test
    it("Testing smart contract function purchaseItem() that allows a consumer to purchase coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        
        
        // Watch the emitted event Purchased()
        

        // Mark an item as Sold by calling function buyItem()
        

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        

        // Verify the result set
        
    })    

    // 9th Test
    it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        
        
        // Verify the result set:
        
    })

    // 10th Test
    it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        
        
        // Verify the result set:
        
    })

});

